<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>EH1003006 PDR Navigator — v0.3.2 (beta)</title>
<meta name="color-scheme" content="dark light">
<style>
  :root{--bg:#0b1020;--ink:#e2e8f0;--muted:#94a3b8;--card:#0f172a;--accent:#60a5fa;--good:#22c55e;--warn:#f59e0b;--bad:#ef4444;}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:12px 14px;background:#0a0f1f;border-bottom:1px solid #17203b;position:sticky;top:0;z-index:10}
  h1{margin:0;font-size:18px}
  .sub{color:var(--muted);font-size:12px;margin-top:4px}
  main{padding:12px 14px;display:grid;gap:12px}
  .card{background:var(--card);border:1px solid #0b1225;border-radius:12px;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:#1f6feb;color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  .btn.secondary{background:#334155}
  .btn.ghost{background:transparent;border:1px solid #334155;color:#e5e7eb}
  .btn.good{background:#15803d}
  .btn.warn{background:#b91c1c}
  .pill{background:#0b1326;border:1px solid #1e293b;border-radius:999px;padding:4px 10px;font-size:12px}
  .pill.ok{border-color:#0f5132;color:#bbf7d0;background:#0b1f14}
  .pill.info{border-color:#1e40af;color:#bfdbfe;background:#0b1326}
  .pill.bad{border-color:#7f1d1d;color:#fecaca;background:#2a0f12}
  .small{font-size:12px;color:var(--muted)}
  .input, select{background:#0b1326;color:#e2e8f0;border:1px solid #1e293b;border-radius:8px;padding:10px}
  .meter{font-variant-numeric:tabular-nums}
  canvas{width:100%;height:340px;background:#0b1326;border:1px solid #1e293b;border-radius:12px}
  .kv{display:grid;grid-template-columns:max-content 1fr; gap:6px 12px; font-size:12px}
  .kv div{padding:2px 0}
  .range{display:flex;align-items:center;gap:8px}
  input[type=range]{width:200px}
</style>
</head>
<body>
<header>
  <h1>EH1003006 PDR Navigator <span class="pill">v0.3.2 beta</span></h1>
  <div class="sub">Android/Pixel-friendly PDR. Live g‑meter, adjustable step threshold, tap‑to‑step test, and baseline calibration.</div>
</header>
<main>
  <div class="card">
    <div class="row">
      <div><b>Anchor</b> <span id="anchorPill" class="pill info">not set</span></div>
      <button id="useStarlink" class="btn">Use Starlink anchor</button>
      <button id="getGPS" class="btn secondary">Use device GPS</button>
      <button id="perm" class="btn ghost">Enable sensors</button>
    </div>
    <div class="small">Open via <b>HTTPS</b> or <b>http://localhost</b>. Chrome → Site settings → Motion sensors → <b>Allowed</b>. Avoid metal roofs/vehicles for heading lock.</div>
    <div class="row" style="margin-top:6px">
      <label>Step length (m) <input id="stepLen" type="number" class="input" value="0.75" step="0.01" style="width:110px"/></label>
      <label>Mag declination (°E + / °W −) <input id="decl" type="number" class="input" value="15" step="0.5" style="width:110px"/></label>
      <label>Auto GPS snap (m) <input id="gpsSnap" type="number" class="input" value="8" step="1" style="width:90px"/></label>
      <label>Heading smoothing (0–1) <input id="headSmooth" type="number" class="input" value="0.85" step="0.05" style="width:110px"/></label>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="start" class="btn good">Start PDR</button>
      <button id="pause" class="btn warn">Pause</button>
      <button id="reset" class="btn ghost">Reset</button>
      <button id="snapNow" class="btn secondary">Snap to GPS now</button>
      <span id="stat" class="small meter" style="margin-left:auto">idle</span>
    </div>
    <div class="row small meter">
      <div>Heading: <span id="heading">—</span>°</div>
      <div>Mag: <span id="mag">—</span>°</div>
      <div>Steps: <span id="steps">0</span></div>
      <div>Speed: <span id="spd">—</span> m/s</div>
      <div>GPS acc: <span id="gacc">—</span> m</div>
    </div>
    <canvas id="map"></canvas>
    <div class="small">North-up grid. One major line = 5 m. Blue = PDR, Green = GPS, Red = current.</div>
  </div>

  <div class="card">
    <div><b>Live sensors & tuning</b></div>
    <div class="row small meter">
      <div>g‑meter: <span id="gmag">—</span> m/s²</div>
      <div class="range">Step threshold
        <input id="thresh" type="range" min="8" max="14" step="0.1" value="11.5"/>
        <span id="threshVal">11.5</span>
      </div>
      <button id="calib" class="btn ghost">Calibrate baseline</button>
      <button id="tapStep" class="btn secondary">Tap to step</button>
    </div>
    <div class="small">Calibration: hold phone still 3 s → sets threshold to baseline + 2.0.</div>
  </div>

  <div class="card">
    <div><b>Sensor diagnostics</b></div>
    <div class="kv" id="diag">
      <div>Secure context</div><div id="d-sec">—</div>
      <div>Motion sensors allowed</div><div id="d-ms">—</div>
      <div>DeviceOrientation</div><div id="d-do">—</div>
      <div>DeviceMotion</div><div id="d-dm">—</div>
      <div>Generic Sensor API</div><div id="d-gs">—</div>
      <div>Magnetometer</div><div id="d-mag">—</div>
      <div>Gyroscope</div><div id="d-gyro">—</div>
      <div>Accelerometer</div><div id="d-acc">—</div>
      <div>OrientationSensor</div><div id="d-aos">—</div>
      <div>Last error</div><div id="d-err">—</div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="exportGeo" class="btn">Export GeoJSON</button>
      <button id="exportCSV" class="btn ghost">Export CSV</button>
    </div>
  </div>
</main>

<script>
// --- Geo helpers ---
const REF = { lat: 46.0201, lon: -122.5488 };
const toRad = d => d * Math.PI/180;
function metersPerDeg(lat){ const mlat = 111320, mlon = 111320 * Math.cos(toRad(lat)); return {mlat, mlon}; }
function addOffset(lat, lon, dist, bearing){ const {mlat, mlon} = metersPerDeg(lat); const dy = dist * Math.cos(toRad(bearing)); const dx = dist * Math.sin(toRad(bearing)); return { lat: lat + dy/mlat, lon: lon + dx/mlon }; }

// --- State ---
let anchor = null;
let running = false;
let points = []; // {t, lat, lon, src:'pdr'|'gps', heading, steps}
let cur = null;
let watchId = null;
let lastGPS = null;

// --- UI refs ---
const el = (id)=> document.getElementById(id);
function pill(set, ok){ set.textContent = ok ? "yes" : "no"; set.className = "pill " + (ok ? "ok":"bad"); }

// --- Diagnostics ---
function diagInit(){
  pill(el('d-sec'), window.isSecureContext);
  pill(el('d-do'), 'ondeviceorientation' in window);
  pill(el('d-dm'), 'ondevicemotion' in window);
  const gs = !!(window.Accelerometer || window.Gyroscope || window.Magnetometer || window.AbsoluteOrientationSensor);
  pill(el('d-gs'), gs);
  pill(el('d-mag'), !!window.Magnetometer);
  pill(el('d-gyro'), !!window.Gyroscope);
  pill(el('d-acc'), !!window.Accelerometer);
  pill(el('d-aos'), !!window.AbsoluteOrientationSensor);
  try{
    if (navigator.permissions && navigator.permissions.query){
      navigator.permissions.query({name:'accelerometer'}).then(r=> el('d-ms').textContent = r.state).catch(()=> el('d-ms').textContent = "unknown");
    } else {
      el('d-ms').textContent = "unknown";
    }
  }catch(e){ el('d-ms').textContent = "unknown"; }
}
diagInit();

// --- Anchor ---
function updateAnchorPill(){ const p = el('anchorPill'); if(!anchor){ p.textContent = "not set"; p.className = "pill info"; } else { p.textContent = anchor.lat.toFixed(6)+", "+anchor.lon.toFixed(6)+" ("+anchor.src+")"; p.className = "pill ok"; } }
el('useStarlink').addEventListener('click', ()=>{ anchor = { lat: REF.lat, lon: REF.lon, src:"starlink" }; cur = { lat: anchor.lat, lon: anchor.lon, heading:0, steps:0 }; updateAnchorPill(); draw(); });
el('getGPS').addEventListener('click', ()=>{
  if(!navigator.geolocation){ el('stat').textContent = "GPS not supported"; return; }
  navigator.geolocation.getCurrentPosition(pos=>{
    const {latitude, longitude, accuracy} = pos.coords;
    anchor = { lat: latitude, lon: longitude, acc: accuracy, src:"device" };
    cur = { lat: anchor.lat, lon: anchor.lon, heading:0, steps:0 };
    updateAnchorPill(); el('gacc').textContent = Math.round(accuracy);
    draw();
  }, err=> el('stat').textContent = "GPS error: "+err.message, {enableHighAccuracy:true, maximumAge:5000, timeout:12000});
});

// --- Sensor handling ---
let smoothedHeading = 0;
function normalize(a){ a = a%360; if(a<0) a+=360; return a; }
function smoothHeading(newH, alpha){ let dh = newH - smoothedHeading; if(dh > 180) dh -= 360; else if(dh < -180) dh += 360; smoothedHeading = normalize(smoothedHeading + alpha*dh); return smoothedHeading; }

let useGeneric = false;
let accelSensor=null, aos=null;
let lastStepT = 0;
let dynamicThreshold = parseFloat(el('thresh').value||"11.5");
el('thresh').addEventListener('input', ()=>{ dynamicThreshold = parseFloat(el('thresh').value); el('threshVal').textContent = dynamicThreshold.toFixed(1); });

async function enableSensors(){
  try{
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') { await DeviceMotionEvent.requestPermission().catch(()=>{}); }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { await DeviceOrientationEvent.requestPermission().catch(()=>{}); }
  }catch(e){ /*ignore*/ }
  try{
    if(window.AbsoluteOrientationSensor){
      aos = new AbsoluteOrientationSensor({frequency: 30});
      aos.addEventListener('reading', ()=>{
        const q = aos.quaternion; if(!q) return;
        const [x,y,z,w] = q;
        const siny_cosp = 2*(w*z + x*y);
        const cosy_cosp = 1 - 2*(y*y + z*z);
        let yaw = Math.atan2(siny_cosp, cosy_cosp);
        let heading = normalize(yaw*180/Math.PI);
        const decl = parseFloat(el('decl').value||"0");
        heading = normalize(heading + decl);
        const alpha = parseFloat(el('headSmooth').value||"0.85");
        const h = smoothHeading(heading, 1-alpha);
        el('mag').textContent = heading.toFixed(0);
        el('heading').textContent = h.toFixed(0);
        if(cur){ cur.heading = h; }
      });
      aos.addEventListener('error', e=>{ el('d-err').textContent = "AOS error: "+(e.error?.message||e.message||e); });
      aos.start(); useGeneric = true;
    }
    if(window.Accelerometer){
      accelSensor = new Accelerometer({frequency: 50});
      accelSensor.addEventListener('reading', ()=>{
        const g = Math.sqrt((accelSensor.x||0)**2 + (accelSensor.y||0)**2 + (accelSensor.z||0)**2);
        el('gmag').textContent = g.toFixed(2);
        if(!running) return;
        const now = performance.now();
        if(g > dynamicThreshold && (now - lastStepT) > 250){ lastStepT = now; step(); }
      });
      accelSensor.addEventListener('error', e=>{ el('d-err').textContent = "Acc error: "+(e.error?.message||e.message||e); });
      accelSensor.start();
    }
  }catch(e){ el('d-err').textContent = "Generic sensors blocked: " + (e.message||e); }

  if(!useGeneric){
    window.addEventListener('deviceorientationabsolute', (e)=>{
      const decl = parseFloat(el('decl').value||"0");
      let mag = e.alpha; if(mag==null) return;
      let trueH = normalize(mag + decl);
      const alpha = parseFloat(el('headSmooth').value||"0.85");
      const h = smoothHeading(trueH, 1-alpha);
      el('mag').textContent = (trueH).toFixed(0);
      el('heading').textContent = h.toFixed(0);
      if(cur){ cur.heading = h; }
    }, true);
    window.addEventListener('deviceorientation', (e)=>{
      if (e.absolute) return;
      const decl = parseFloat(el('decl').value||"0");
      let mag = e.alpha; if(mag==null) return;
      let trueH = normalize(mag + decl);
      const alpha = parseFloat(el('headSmooth').value||"0.85");
      const h = smoothHeading(trueH, 1-alpha);
      el('mag').textContent = (trueH).toFixed(0);
      el('heading').textContent = h.toFixed(0);
      if(cur){ cur.heading = h; }
    }, true);
    window.addEventListener('devicemotion', (e)=>{
      const a = e.accelerationIncludingGravity; if(!a) return;
      const g = Math.sqrt((a.x||0)**2 + (a.y||0)**2 + (a.z||0)**2);
      el('gmag').textContent = g.toFixed(2);
      if(!running) return;
      const now = performance.now();
      if(g > dynamicThreshold && (now - lastStepT) > 250){ lastStepT = now; step(); }
    }, true);
  }
  el('stat').textContent = (useGeneric? "sensors: generic":"sensors: legacy") + (window.isSecureContext ? "" : " (non-secure: some sensors may be blocked)");
}
el('perm').addEventListener('click', enableSensors);

// Calibration: hold still for 3 s
el('calib').addEventListener('click', ()=>{
  const samples = []; const t0 = performance.now();
  function onRead(g){
    samples.push(g);
    if(performance.now() - t0 >= 3000){
      const mean = samples.reduce((s,x)=>s+x,0)/Math.max(1,samples.length);
      dynamicThreshold = mean + 2.0;
      el('thresh').value = dynamicThreshold; el('threshVal').textContent = dynamicThreshold.toFixed(1);
      window.removeEventListener('devicemotion', dmListener, true);
      el('d-err').textContent = "Calibrated threshold to " + dynamicThreshold.toFixed(2);
    }
  }
  function dmListener(e){
    const a = e.accelerationIncludingGravity||{}; const g = Math.sqrt((a.x||0)**2 + (a.y||0)**2 + (a.z||0)**2);
    onRead(g);
  }
  if(window.Accelerometer){
    const s = new Accelerometer({frequency: 50});
    s.addEventListener('reading', ()=> onRead(Math.sqrt((s.x||0)**2 + (s.y||0)**2 + (s.z||0)**2)));
    s.start();
    setTimeout(()=>{ try{s.stop();}catch{} }, 3100);
  }else{
    window.addEventListener('devicemotion', dmListener, true);
    setTimeout(()=> window.removeEventListener('devicemotion', dmListener, true), 3100);
  }
});

// Tap-to-step test
el('tapStep').addEventListener('click', ()=> step());

// --- Step & GPS ---
function step(){
  if(!cur) return;
  const stepLen = Math.max(0.3, parseFloat(el('stepLen').value||"0.75"));
  cur.steps = (cur.steps||0) + 1;
  const next = addOffset(cur.lat, cur.lon, stepLen, cur.heading||0);
  cur.lat = next.lat; cur.lon = next.lon;
  points.push({ t: Date.now(), lat: cur.lat, lon: cur.lon, src:'pdr', heading: cur.heading||0, steps: cur.steps });
  el('steps').textContent = cur.steps;
  draw();
}

function startGPSWatch(){
  if(!navigator.geolocation) return;
  watchId = navigator.geolocation.watchPosition(pos=>{
    const {latitude, longitude, accuracy, speed} = pos.coords;
    lastGPS = { lat: latitude, lon: longitude, acc: accuracy, spd: speed||0, t: Date.now() };
    el('gacc').textContent = accuracy ? Math.round(accuracy) : "—";
    el('spd').textContent = isFinite(speed) ? (speed||0).toFixed(2) : "—";
    const snap = parseFloat(el('gpsSnap').value||"8");
    if(snap && accuracy && accuracy <= snap){
      if(cur){
        cur.lat = (cur.lat*3 + latitude)/4;
        cur.lon = (cur.lon*3 + longitude)/4;
        points.push({ t: Date.now(), lat: latitude, lon: longitude, src:'gps', heading: cur.heading||0, steps: cur.steps||0 });
        draw();
      }
    }
  }, err=>{}, {enableHighAccuracy:true, maximumAge:2000, timeout:12000});
}
function stopGPSWatch(){ if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; } }
el('snapNow').addEventListener('click', ()=>{ if(lastGPS && cur){ cur.lat = lastGPS.lat; cur.lon = lastGPS.lon; points.push({ t: Date.now(), lat: cur.lat, lon: cur.lon, src:'gps', heading: cur.heading||0, steps: cur.steps||0 }); draw(); } });

// --- Controls ---
el('start').addEventListener('click', ()=>{ if(!anchor){ alert("Set anchor first."); return; } if(!cur) cur = { lat: anchor.lat, lon: anchor.lon, heading: 0, steps: 0 }; running = true; el('stat').textContent = "running"; startGPSWatch(); });
el('pause').addEventListener('click', ()=>{ running = false; el('stat').textContent = "paused"; stopGPSWatch(); });
el('reset').addEventListener('click', ()=>{ running = false; stopGPSWatch(); points = []; cur = anchor ? { lat: anchor.lat, lon: anchor.lon, heading:0, steps:0 } : null; el('steps').textContent = "0"; el('stat').textContent = "idle"; draw(); });

// --- Drawing ---
const canvas = document.getElementById('map'); const ctx = canvas.getContext('2d');
function resizeCanvas(){ const r = window.devicePixelRatio || 1; canvas.width = Math.floor(canvas.clientWidth * r); canvas.height = Math.floor(canvas.clientHeight * r); }
window.addEventListener('resize', ()=>{ resizeCanvas(); draw(); }); resizeCanvas();
function latlonToLocal(lat, lon, refLat, refLon){ const {mlat, mlon} = metersPerDeg(refLat); const dx = (lon - refLon) * mlon; const dy = (lat - refLat) * mlat; return {x: dx, y: dy}; }
function draw(){
  resizeCanvas(); ctx.clearRect(0,0,canvas.width,canvas.height); const w = canvas.width, h = canvas.height; ctx.save();
  let center = anchor || {lat: REF.lat, lon: REF.lon}; if(cur){ center = { lat: cur.lat, lon: cur.lon }; }
  const localPts = points.map(p => ({...p, ...latlonToLocal(p.lat,p.lon, center.lat, center.lon)}));
  const mPerPix = 0.2 * Math.max(1,  (Math.max(10, localPts.reduce((M,p)=>Math.max(M, Math.hypot(p.x,p.y)), 0)) / (Math.min(w,h)/3)) );
  const gridStep = 5; const pxPerMeter = 1 / mPerPix;
  ctx.strokeStyle = "#1e293b"; ctx.lineWidth = 1; ctx.beginPath();
  for(let gx=-100; gx<=100; gx+=gridStep){ const x = w/2 + gx*pxPerMeter; ctx.moveTo(x, 0); ctx.lineTo(x, h); }
  for(let gy=-100; gy<=100; gy+=gridStep){ const y = h/2 - gy*pxPerMeter; ctx.moveTo(0, y); ctx.lineTo(w, y); }
  ctx.stroke();
  ctx.lineWidth = 3; ctx.strokeStyle = "#16a34a"; ctx.beginPath();
  localPts.filter(p=>p.src==='gps').forEach((p,i)=>{ const x = w/2 + p.x*pxPerMeter, y = h/2 - p.y*pxPerMeter; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke();
  ctx.strokeStyle = "#60a5fa"; ctx.beginPath();
  localPts.filter(p=>p.src==='pdr').forEach((p,i)=>{ const x = w/2 + p.x*pxPerMeter, y = h/2 - p.y*pxPerMeter; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke();
  if(cur){ const c = latlonToLocal(cur.lat, cur.lon, center.lat, center.lon); const x = w/2 + c.x*pxPerMeter, y = h/2 - c.y*pxPerMeter; ctx.fillStyle = "#ef4444"; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill(); const brg = (cur.heading||0)*Math.PI/180; ctx.strokeStyle = "#ef4444"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.sin(brg)*20, y-Math.cos(brg)*20); ctx.stroke(); }
  ctx.restore();
}

// --- Export ---
function download(name, data, type='application/octet-stream'){ const blob = new Blob([data], {type}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = name; a.click(); URL.revokeObjectURL(url); }
el('exportGeo').addEventListener('click', ()=>{ const fc = { type: "FeatureCollection", features: [ { type: "Feature", properties: { name: "PDR path" }, geometry: { type: "LineString", coordinates: points.map(p=>[p.lon, p.lat]) } } ] }; download("eh1003006_pdr_path_v0_3_2.geojson", JSON.stringify(fc, null, 2), "application/geo+json"); });
el('exportCSV').addEventListener('click', ()=>{ const csv = "t,lat,lon,src,heading,steps\n" + points.map(p=>[p.t,p.lat,p.lon,p.src,p.heading??"",p.steps??""].join(",")).join("\n"); download("eh1003006_pdr_path_v0_3_2.csv", csv, "text/csv"); });
</script>
</body>
</html>
