<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EH1003006 Online Planner — v5.2.8</title>

  <!-- Core map libs -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.14.2/dist/leaflet-geoman.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.14.2/dist/leaflet-geoman.min.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/chart.js@4.4.3/dist/chart.umd.js"></script>

  <!-- Local GeoTIFF raster rendering + analysis -->
  <script src="https://unpkg.com/geotiff/dist-browser/geotiff.js"></script>
  <script src="https://unpkg.com/georaster/dist/georaster.browser.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>
  <script src="https://unpkg.com/proj4@2.11.0/dist/proj4.js"></script>
  <script src="https://unpkg.com/geoblaze@1.3.4/dist/geoblaze.umd.js"></script>

  <style>
    :root {
      --bg: #0b1020; --panel: #0f172a; --card: #0c1930; --ink: #e2e8f0; --muted: #94a3b8;
      --accent: #60a5fa; --accent-2: #22c55e; --warn: #f97316; --danger: #ef4444;
    }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: system-ui, ui-sans-serif, Segoe UI, Roboto, Helvetica, Arial; }
    #app { display:grid; grid-template-rows: auto auto 1fr auto; gap:10px; height:100%; }
    #toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; padding:10px 12px; background:var(--panel); border-bottom:1px solid #1f2937; }
    #map { height: 56vh; }
    #panel { display:grid; grid-template-columns: repeat(12, 1fr); gap:10px; padding:10px 12px; background:var(--panel); }
    #footer { padding:8px 12px; font-size:12px; color:var(--muted); background:#0a0f1f; border-top:1px solid #1f2937; }
    .badge { font-size:12px; background:rgba(96,165,250,0.15); color:#93c5fd; padding:2px 8px; border-radius:999px; border:1px solid rgba(96,165,250,0.35); }
    .btn { padding:8px 12px; border-radius:10px; background:#1f6feb; color:white; cursor:pointer; border:none; font-weight:600; }
    .btn.secondary { background:#334155; }
    .btn.ghost { background:transparent; border:1px solid #334155; color:#e5e7eb; }
    .btn.warn { background:#b91c1c; }
    .btn.good { background:#16a34a; }
    .pill { background:#0b1326; padding:4px 8px; border:1px solid #1e293b; border-radius:999px; min-width:64px; text-align:center; color:#e2e8f0; }
    .kbd { font-family: ui-monospace, Menlo, Consolas, monospace; font-size:12px; background:#0b1326; border:1px solid #1e293b; padding:0 6px; border-radius:6px; color:#cbd5e1; }
    .card { background:var(--card); border:1px solid #0b1225; border-radius:12px; padding:10px; }
    .card h3 { margin:0 0 8px 0; font-size:14px; color:#cbd5e1; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .col { display:flex; flex-direction:column; gap:8px; }
    .input { background:#0b1326; color:#e2e8f0; border:1px solid #1e293b; padding:6px 8px; border-radius:8px; }
    .small { font-size:12px; color:var(--muted); }
    .switch { display:inline-flex; align-items:center; gap:6px; }
    .version-badge { position:absolute; top:10px; left:10px; z-index:1000; background:rgba(0,0,0,0.6); color:#fff; padding:6px 10px; border-radius:8px; font-size:12px; }
    #profile { height: 28vh; }
    .legendBox { font-size:12px; background:#0b1326; border:1px solid #1e293b; border-radius:8px; padding:8px 10px; }
    .divider { height:1px; background:#1e293b; margin:8px 0; }
    .layer-row { display:flex; align-items:center; gap:8px; margin-bottom:4px; }
    .layer-row input[type=range] { width:120px; }
    .badge.good { background:rgba(34,197,94,0.12); color:#86efac; border-color:rgba(34,197,94,0.35); }
  </style>
</head>
<body>
<div id="app">
  <!-- Top info line -->
  <div id="toolbar">
    <span class="badge">EH1003006 • 46.0201, -122.5488 (Cowlitz, WA)</span>
    <span class="badge">Starlink • Wi‑Fi + cams • Solar present</span>
    <span class="badge">Invasives: Himalayan blackberry</span>
    <span class="badge">Online Planner v5.2.8</span>
    <span id="lidarBadge" class="badge">LiDAR: loading…</span>
  </div>

  <!-- Map -->
  <div id="map"></div>
  <div class="version-badge"><strong>EH1003006 Online Planner</strong> — v5.2.8</div>

  <!-- Control panel -->
  <div id="panel">
    <!-- Hydro + power -->
    <div class="card" style="grid-column:span 4;">
      <h3>Hydro Profile & Power</h3>
      <div class="row">
        <div>Active line: <span id="activeName" class="pill">–</span></div>
        <button id="recalc" class="btn">Recompute</button>
        <button id="clear" class="btn secondary">Clear</button>
      </div>
      <div class="row">
        <div>Length: <span id="len" class="pill">–</span></div>
        <div>Start: <span id="z0" class="pill">–</span></div>
        <div>End: <span id="z1" class="pill">–</span></div>
        <div>Head: <span id="drop" class="pill">–</span></div>
        <div>Slope: <span id="slope" class="pill">–</span></div>
      </div>
      <div class="row">
        <div>Gain: <span id="gain" class="pill">–</span></div>
        <div>Loss: <span id="loss" class="pill">–</span></div>
      </div>
      <div class="row" style="margin-top:6px;">
        <label>Flow (cfs) <input id="flowCFS" class="input" type="number" value="0.50" step="0.01" min="0" style="width:90px;"/></label>
        <label>η (0–1) <input id="eta" class="input" type="number" value="0.70" step="0.01" min="0" max="1" style="width:90px;"/></label>
      </div>
      <div class="row" style="margin-top:6px;">
        <span id="powerW" class="pill">– W</span>
        <span id="powerkW" class="pill">– kW</span>
        <span id="hp" class="pill">– hp</span>
      </div>
      <div class="row" style="margin-top:6px;">
        <span class="btn ghost chip" data-flow="0.20">0.20</span>
        <span class="btn ghost chip" data-flow="0.50">0.50</span>
        <span class="btn ghost chip" data-flow="1.00">1.00</span>
        <span class="btn ghost chip" data-flow="1.50">1.50</span>
      </div>
      <div class="divider"></div>
      <div class="row">
        <label class="switch"><input type="checkbox" id="useLocalLidar" checked /> <span>Use local LiDAR for elevation (fallback: USGS)</span></label>
      </div>
      <div class="divider"></div>
      <div class="row">
        <label>Battery (Wh) <input id="batteryWh" class="input" type="number" value="5040" step="10" min="0" style="width:120px;"/></label>
        <label>Duty (0–1) <input id="duty" class="input" type="number" value="1.00" step="0.05" min="0" max="1" style="width:90px;"/></label>
      </div>
      <div class="row" style="margin-top:6px;">
        <span id="dailyKWh" class="pill">Daily: – kWh</span>
        <span id="timeToFill" class="pill">Charge time: – h</span>
      </div>
      <div class="small">Elevations: local LiDAR DTM when available; USGS EPQS fallback. Head is gross; friction reduces net.</div>
    </div>

    <!-- Online basemaps & overlays -->
    <div class="card" style="grid-column:span 4;">
      <h3>Online Layers</h3>
      <div id="layerList" class="small"></div>
    </div>

    <!-- Analyzer + vegetation -->
    <div class="card" style="grid-column:span 4;">
      <h3>Site Planner & Vegetation</h3>
      <div class="legendBox">
        <div class="row">
          <div class="switch"><input type="checkbox" id="veg-toggle" /> <label for="veg-toggle"><strong>Vegetation mode</strong> (draw blackberry patches)</label></div>
        </div>
        <div class="small">Polygons drawn while vegetation mode is ON are styled purple and grouped under <i>Vegetation</i>.</div>
      </div>

      <div class="legendBox" style="margin-top:8px;">
        <div class="row">
          <label class="btn ghost" for="geojsonFile">Upload GeoJSON</label>
          <input id="geojsonFile" type="file" accept=".geojson,application/geo+json,application/json" style="display:none;" />
          <button id="exportNotes" class="btn secondary">Export notes (.geojson)</button>
          <label class="btn ghost" for="importNotes">Import notes</label>
          <input id="importNotes" type="file" accept=".geojson,application/json" style="display:none;" />
        </div>
        <div class="row" style="margin-top:6px;">
          <select id="layerRole" class="input" style="width:160px;">
            <option value="streams">streams</option>
            <option value="hydrology">hydrology</option>
            <option value="floodplain">floodplain</option>
            <option value="wetlands">wetlands</option>
            <option value="slope">slope</option>
            <option value="aspect">aspect</option>
            <option value="blackberry">blackberry</option>
            <option value="parcel">parcel</option>
            <option value="roads">roads</option>
            <option value="buildings">buildings</option>
            <option value="utilities">utilities</option>
            <option value="custom" selected>custom</option>
          </select>
          <input id="layerName" class="input" placeholder="Layer name (optional)" style="width:200px;" />
          <button id="assignRole" class="btn secondary">Assign role to last uploaded</button>
        </div>
        <div class="divider"></div>
        <button id="analyzeBtn" class="btn good">Analyze Selected Features</button>
        <div id="report" class="small" style="margin-top:8px; max-height:180px; overflow:auto;"></div>
      </div>
    </div>

    <!-- Profile chart (full width) -->
    <div class="card" style="grid-column:span 12;">
      <canvas id="profile"></canvas>
    </div>
  </div>

  <!-- Footer -->
  <div id="footer">
    <div>Draw penstock with the pencil, click intake (high) → powerhouse (low). Double‑click to finish. You can edit vertices, then <span class="kbd">Recompute</span>. Bookmarks live in your browser (localStorage). Export notes file name now includes <strong>v5.2.8</strong>.</div>
  </div>
</div>

<script>
// --- Map init ---
const center = [46.0201, -122.5488];
const map = L.map('map', { center, zoom: 17 });

// === EH1003006 Parcel (always-on default) ===
const parcelGeoJSON = {"type":"FeatureCollection","features":[{"type":"Feature","properties":{},"geometry":{"type":"Polygon","coordinates":[[[-122.55044,46.020375],[-122.550483,46.018312],[-122.547865,46.018312],[-122.547865,46.018848],[-122.545161,46.018848],[-122.545129,46.020383],[-122.55044,46.020375]]]}}]};
const parcelLayer = L.geoJSON(parcelGeoJSON, { style: { color:'#ef4444', weight:3, fillOpacity:0.06 } });
const parcelCenter = [46.0201, -122.5488];
const parcelNotes = L.marker(parcelCenter).bindPopup(`
  <b>Parcel:</b> EH1003006<br/>
  <b>County:</b> Cowlitz, WA<br/>
  <b>Coords:</b> 46.020100, -122.548800<br/>
  <hr style="margin:6px 0" />
  <div style="font-size:12px;line-height:1.2">
    Starlink unlimited internet<br/>
    Onsite Wi‑Fi & security cameras<br/>
    Solar present<br/>
    Issue: invasive blackberries
  </div>
`);
const parcelGroup = L.layerGroup([
  parcelLayer,
  parcelNotes,
  L.circle(parcelCenter, { radius: 250, color: '#1d4ed8', weight: 1, fillOpacity: 0.03 }).bindTooltip('250 m reference')
]);
parcelGroup.addTo(map);
try { map.fitBounds(parcelLayer.getBounds()); } catch(e){}

// --- Geoman controls ---
map.pm.addControls({
  position: 'topleft', drawMarker: true, drawPolyline: true, drawRectangle: true,
  drawCircle: true, drawPolygon: true, editMode: true, dragMode: true, cutPolygon: true, removalMode: true
});

// --- Feature groups ---
const drawn = L.featureGroup().addTo(map);
const vegGroup = L.featureGroup().addTo(map);
const endpoints = L.layerGroup().addTo(map);

// --- Vegetation mode ---
let vegMode = false;
document.getElementById('veg-toggle').addEventListener('change', (e) => {
  vegMode = !!e.target.checked;
  map.pm.setPathOptions(vegMode ? { color:'#7e22ce', fillColor:'#7e22ce', fillOpacity:0.25 } : { color:'#e2e8f0', fillColor:'#1f2937' });
});

// --- Basemaps ---
const usgsTopo = L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'USGS' }).addTo(map);
const usgsImageryTopo = L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'USGS' });

// --- Online dynamic overlays (Esri Leaflet) ---
const overlays = {
  'Parcel & Notes': parcelGroup,
  "WA DNR LiDAR Hillshade": L.esri.dynamicMapLayer({ url: 'https://gis.dnr.wa.gov/site1/rest/services/Public_Geology/Lidar_Hillshade/MapServer', opacity: 0.6 }),
  "WA DNR Forest Practices Hydro": L.esri.dynamicMapLayer({ url: 'https://gis.dnr.wa.gov/site2/rest/services/Public_Forest_Practices/WADNR_PUBLIC_FP_Hydro/MapServer', opacity: 0.85 }),
  "USGS NHD (Hydrography)": L.esri.dynamicMapLayer({ url: 'https://hydro.nationalmap.gov/arcgis/rest/services/nhd/MapServer', opacity: 0.8 }),
  "USGS WBD (Watersheds)": L.esri.dynamicMapLayer({ url: 'https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer', opacity: 0.7 }),
  "FEMA NFHL (Floodplain)": L.esri.dynamicMapLayer({ url: 'https://hazards.fema.gov/arcgis/rest/services/public/NFHL/MapServer', opacity: 0.75 }),
  "USFWS NWI Wetlands": L.esri.dynamicMapLayer({ url: 'https://fwspublicservices.wim.usgs.gov/wetlandsmapservice/rest/services/Wetlands/MapServer', opacity: 0.75 }),
  "NRCS Soils (SSURGO sample)": L.esri.dynamicMapLayer({ url: 'https://nrcsgeoservices.sc.egov.usda.gov/arcgis/rest/services/soils/ssurgo_for_rsvi/MapServer', opacity: 0.7 }),
  "NOAA/USGS Stream Gauges (ref)": L.esri.dynamicMapLayer({ url: 'https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/USGS_Stream_Gauges/MapServer', opacity: 0.9 })
};

// Layer switcher UI with opacity sliders
const layerList = document.getElementById('layerList');
function addLayerRow(name, layer){
  const row = document.createElement('div');
  row.className = 'layer-row';
  const chk = document.createElement('input'); chk.type = 'checkbox';
  try { chk.checked = false; } catch(_) { chk.checked = false; }
  const label = document.createElement('label'); label.textContent = name;
  const slider = document.createElement('input'); slider.type = 'range'; slider.min=0; slider.max=1; slider.step=0.05; slider.value=layer.options.opacity ?? 1;
  chk.addEventListener('change', () => { if(chk.checked) layer.addTo(map); else layer.remove(); });
  slider.addEventListener('input', () => layer.setOpacity(parseFloat(slider.value)));
  row.appendChild(chk); row.appendChild(label); row.appendChild(slider);
  layerList.appendChild(row);
}
Object.entries(overlays).forEach(([name, layer]) => addLayerRow(name, layer));

L.control.layers({ 'USGS Topo': usgsTopo, 'USGS ImageryTopo': usgsImageryTopo }, null, { position:'topright' }).addTo(map);

// --- Multiband stack config (assumes order: DTM, Slope, Aspect, CHM) ---
const BANDMAP = { DTM: 0, SLOPE: 1, ASPECT: 2, CHM: 3 };
const STACK_CANDIDATES = [
  'eh1003006_stack_v1_1_cog.tif',     // preferred
  'eh1003006_combined_bands_v1_0.tif' // existing
];

async function fetchArrayBufferFrom(urls){
  for(const u of urls){
    try {
      const res = await fetch(u);
      if(res.ok){ const buf = await res.arrayBuffer(); return { url: u, buf }; }
    } catch(e){}
  }
  throw new Error('No URL available');
}

// Color ramps
function rampGreen(v, vmin, vmax){
  v = Array.isArray(v) ? v[0] : v;
  if(v==null || isNaN(v)) return null;
  const t = Math.max(0, Math.min(1, (v - vmin)/(vmax - vmin)));
  const g = Math.floor(40 + 180*t);
  const r = Math.floor(20 + 50*t);
  const b = Math.floor(20 + 40*(1-t));
  return `rgba(${r},${g},${b},1)`;
}
function rampSlope(v){
  v = Array.isArray(v) ? v[0] : v;
  if(v==null || isNaN(v)) return null;
  if(v < 10) return 'rgba(34,197,94,0.85)';
  if(v < 30) return 'rgba(245,158,11,0.85)';
  return 'rgba(239,68,68,0.9)';
}
function colorAspect(v){
  v = Array.isArray(v) ? v[0] : v;
  if(v==null || isNaN(v)) return null;
  const d = ((v%360)+360)%360;
  if(d<45) return 'rgba(59,130,246,0.7)';
  if(d<90) return 'rgba(45,212,191,0.7)';
  if(d<135) return 'rgba(16,185,129,0.7)';
  if(d<180) return 'rgba(132,204,22,0.7)';
  if(d<225) return 'rgba(234,179,8,0.7)';
  if(d<270) return 'rgba(249,115,22,0.7)';
  if(d<315) return 'rgba(168,85,247,0.7)';
  return 'rgba(99,102,241,0.7)';
}

function makeBandLayer(georaster, bandIndex, pixelValuesToColorFn, opts={}){
  return new GeoRasterLayer({
    georaster,
    opacity: opts.opacity ?? 0.6,
    resolution: opts.resolution ?? 96,
    pixelValuesToColorFn: (vals) => {
      const v = Array.isArray(vals) ? vals[bandIndex] : vals;
      return pixelValuesToColorFn([v]);
    }
  });
}

let localDTM = null; // georaster object (stack or single)
let dtmLayer = null; // base layer

(async function loadRasters(){
  const badge = document.getElementById('lidarBadge');

  // 1) Try multiband stack first
  try {
    const { buf: stackBuf } = await fetchArrayBufferFrom(STACK_CANDIDATES);
    const stackRaster = await parseGeoraster(stackBuf);
    localDTM = stackRaster;

    // DTM base (greyscale stretch)
    const MIN_FT = 1106, MAX_FT = 1476;
    dtmLayer = new GeoRasterLayer({
      georaster: stackRaster, opacity: 0.85, resolution: 96,
      pixelValuesToColorFn: (vals) => {
        const v = Array.isArray(vals) ? vals[BANDMAP.DTM] : vals;
        if (v == null || isNaN(v)) return null;
        const t = Math.max(0, Math.min(1, (v - MIN_FT) / (MAX_FT - MIN_FT)));
        const g = Math.floor(255 * t);
        return `rgba(${g},${g},${g},1)`;
      }
    }).addTo(map);
    addLayerRow('EH1003006 DTM (stack, local)', dtmLayer);
    try { map.fitBounds(dtmLayer.getBounds()); } catch (e) {}

    // Optional overlays from bands (start OFF)
    const slopeLayer = makeBandLayer(stackRaster, BANDMAP.SLOPE, rampSlope, { opacity:0.55 });
    addLayerRow('Slope % (stack, local)', slopeLayer);

    const aspectLayer = makeBandLayer(stackRaster, BANDMAP.ASPECT, colorAspect, { opacity:0.5 });
    addLayerRow('Aspect ° (stack, local)', aspectLayer);

    const CHM_MIN = 0, CHM_MAX = 40;
    const chmLayer = makeBandLayer(stackRaster, BANDMAP.CHM, (vals)=>rampGreen(vals, CHM_MIN, CHM_MAX), { opacity:0.6 });
    addLayerRow('Canopy Height (stack, local)', chmLayer);

    badge.textContent = 'LiDAR (stack): loaded';
    badge.classList.add('good');
    return; // done
  } catch (e) {
    console.log('No stack; falling back to singles...', e);
  }

  // 2) Fallback: single-file DTM + optional single-file overlays
  try {
    const { buf } = await fetchArrayBufferFrom([
      '../data/eh1003006_dtm_clip.tif','eh1003006_dtm_clip.tif',
      'lidar_extract/be_w1118250n256500_dtm.tif','../data/lidar_extract/be_w1118250n256500_dtm.tif'
    ]);
    localDTM = await parseGeoraster(buf);

    const MIN_FT = 1106, MAX_FT = 1476;
    dtmLayer = new GeoRasterLayer({
      georaster: localDTM, opacity: 0.85, resolution: 96,
      pixelValuesToColorFn: ([v]) => {
        if (v == null || isNaN(v)) return null;
        const t = Math.max(0, Math.min(1, (v - MIN_FT) / (MAX_FT - MIN_FT)));
        const g = Math.floor(255 * t);
        return `rgba(${g},${g},${g},1)`;
      }
    }).addTo(map);
    addLayerRow('EH1003006 LiDAR DTM (local)', dtmLayer);
    try { map.fitBounds(dtmLayer.getBounds()); } catch(e){}
    badge.textContent = 'LiDAR DTM: loaded'; badge.classList.add('good');
  } catch (err) {
    console.error(err); badge.textContent = 'LiDAR DTM: failed (using online only)';
  }

  // Optional singles (only if present)
  try {
    const { buf } = await fetchArrayBufferFrom(['eh1003006_slope_pct.tif','../data/eh1003006_slope_pct.tif']);
    const slopeRaster = await parseGeoraster(buf);
    const slopeLayer = new GeoRasterLayer({
      georaster: slopeRaster, opacity: 0.55, resolution: 96,
      pixelValuesToColorFn: ([v]) => rampSlope(v)
    });
    addLayerRow('Slope % (local)', slopeLayer);
  } catch(e){}

  try {
    const { buf } = await fetchArrayBufferFrom(['eh1003006_aspect_deg.tif','../data/eh1003006_aspect_deg.tif']);
    const aspectRaster = await parseGeoraster(buf);
    const aspectLayer = new GeoRasterLayer({
      georaster: aspectRaster, opacity: 0.5, resolution: 96,
      pixelValuesToColorFn: ([v]) => colorAspect(v)
    });
    addLayerRow('Aspect ° (local)', aspectLayer);
  } catch(e){}

  try {
    const { buf } = await fetchArrayBufferFrom(['eh1003006_chm.tif','../data/eh1003006_chm.tif']);
    const chmRaster = await parseGeoraster(buf);
    const CHM_MIN = 0, CHM_MAX = 40;
    const chmLayer = new GeoRasterLayer({
      georaster: chmRaster, opacity: 0.6, resolution: 96,
      pixelValuesToColorFn: ([v]) => rampGreen(v, CHM_MIN, CHM_MAX)
    });
    addLayerRow('Canopy Height (local)', chmLayer);
  } catch(e){}
})();

// --- Chart setup ---
const ctx = document.getElementById('profile');
let chart = new Chart(ctx, {
  type: 'line',
  data: { labels: [], datasets: [{ label: 'Elevation (ft)', data: [], fill:false, tension: 0.15 }] },
  options: { responsive:true, maintainAspectRatio:false, scales: { x: { title:{ display:true, text:'Distance (ft)' } }, y: { title:{ display:true, text:'Elevation (ft)' } } } }
});

// --- USGS EPQS (fallback) ---
async function epqsFeet(lon, lat){
  const url = `https://epqs.nationalmap.gov/v1/json?x=${lon}&y=${lat}&units=Feet&wkid=4326`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('EPQS error');
  const js = await res.json();
  return js?.value ?? js?.elevation ?? null;
}

// Utilities
function haversine(m1, m2){
  const R = 6371000; const toRad = x => x*Math.PI/180;
  const dLat = toRad(m2[0]-m1[0]); const dLon = toRad(m2[1]-m1[1]);
  const lat1 = toRad(m1[0]); const lat2 = toRad(m2[0]);
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}
function interpolateLatLng(lineLatLng, n){
  let segLens=[],cum=[0]; for(let i=1;i<lineLatLng.length;i++){ segLens[i-1]=haversine(lineLatLng[i-1],lineLatLng[i]); cum[i]=cum[i-1]+segLens[i-1]; }
  const total=cum[cum.length-1]; const out=[];
  for(let i=0;i<n;i++){ const d=(i/(n-1))*total; let s=0; while(s<segLens.length&&cum[s+1]<d) s++; const remain=d-cum[s]; const t=segLens[s]===0?0:remain/segLens[s];
    const p0=lineLatLng[s],p1=lineLatLng[s+1]; out.push([p0[0]+(p1[0]-p0[0])*t,p0[1]+(p1[1]-p0[1])*t,d]); }
  return {pts:out,total};
}

function setStats(totalMeters, elevs){
  const ft = totalMeters * 3.28084;
  let gain=0, loss=0; for(let i=1;i<elevs.length;i++){ const d=elevs[i]-elevs[i-1]; if(d>0) gain+=d; else loss+=-d; }
  const start = elevs[0]; const end = elevs[elevs.length-1];
  const head = Math.max(0, start - end);
  const avgSlope = head / (ft||1) * 100;
  document.getElementById('len').innerText = ft.toFixed(0)+' ft';
  document.getElementById('z0').innerText = start.toFixed(0)+' ft';
  document.getElementById('z1').innerText = end.toFixed(0)+' ft';
  document.getElementById('drop').innerText = head.toFixed(0)+' ft';
  document.getElementById('slope').innerText = avgSlope.toFixed(1)+' %';
  document.getElementById('gain').innerText = gain.toFixed(0)+' ft';
  document.getElementById('loss').innerText = loss.toFixed(0)+' ft';
  computePower(head);
}

// Throttled helpers
async function throttleMap(items, limit, fn){
  const results = new Array(items.length);
  let i = 0;
  const workers = new Array(limit).fill(0).map(async () => {
    while (i < items.length) {
      const idx = i++;
      try { results[idx] = await fn(items[idx], idx); } catch(e){ results[idx] = null; }
    }
  });
  await Promise.all(workers);
  return results;
}

// --- Local LiDAR sampling (works for stack: uses band 0 as DTM) ---
async function sampleLocalDTM(coords /* [[lat, lon], ...] */){
  if(!localDTM) throw new Error('No local DTM loaded');
  // Try to detect EPSG in georaster projection
  let targetEPSG = null;
  const proj = localDTM.projection;
  if (proj && typeof proj === 'string') {
    const m = proj.match(/EPSG:\d+/i);
    if (m) targetEPSG = m[0].toUpperCase();
  }
  const transform = (lon, lat) => targetEPSG ? proj4('EPSG:4326', targetEPSG, [lon, lat]) : [lon, lat];
  const out = await throttleMap(coords, 10, async ([lat, lon]) => {
    try {
      const [x, y] = transform(lon, lat);
      const v = await geoblaze.identify(localDTM, [x, y]);
      const val = Array.isArray(v) ? v[0] : v; // band 0 is DTM
      return (val==null || isNaN(val)) ? null : Number(val);
    } catch(e){ return null; }
  });
  // Forward/backfill nulls if any
  for(let i=0;i<out.length;i++) if(out[i]==null) out[i]=(out[i-1]??null);
  for(let i=out.length-1;i>=0;i--) if(out[i]==null) out[i]=(out[i+1]??0);
  return out;
}

async function sampleEPQS(coords /* [[lat, lon], ...] */){
  return await throttleMap(coords, 8, async ([lat, lon]) => await epqsFeet(lon, lat));
}

async function profileForPolyline(poly){
  const latlngs = poly.getLatLngs().map(p => [p.lat, p.lng]);
  if(latlngs.length < 2){ alert('Add more points to the line.'); return; }
  const N = Math.min(240, Math.max(80, Math.floor(latlngs.length*50)));
  const { pts, total } = interpolateLatLng(latlngs, N);
  const coords = pts.map(([lat, lon]) => [lat, lon]);

  const useLocal = document.getElementById('useLocalLidar').checked && !!localDTM;
  let elevs = null; let sourceLabel = '';
  if(useLocal){
    try { elevs = await sampleLocalDTM(coords); sourceLabel = 'Local LiDAR'; }
    catch(e){ console.warn('Local LiDAR sampling failed, falling back to EPQS', e); }
  }
  if(!elevs || elevs.some(v => v==null)) { elevs = await sampleEPQS(coords); sourceLabel = 'USGS EPQS'; }

  const labels = pts.map(p => (p[2]*3.28084).toFixed(0));
  chart.data.labels = labels;
  chart.data.datasets[0].data = elevs;
  chart.data.datasets[0].label = `Elevation (ft) — ${sourceLabel}`;
  chart.update();
  setStats(total, elevs);
}

// Power calc (flow in cfs, head in ft)
function computePower(headFt){
  const flowCFS = parseFloat(document.getElementById('flowCFS').value || '0') || 0;
  const eta = Math.min(1, Math.max(0, parseFloat(document.getElementById('eta').value || '0.7')));
  const Q = flowCFS * 0.028316846592; // m^3/s
  const H = headFt * 0.3048;          // m
  const rho = 1000, g = 9.80665;
  const P = eta * rho * g * Q * H;    // Watts
  const kW = P / 1000;
  const hp = P / 745.699872;
  document.getElementById('powerW').innerText = (isFinite(P)?P:0).toFixed(0)+' W';
  document.getElementById('powerkW').innerText = (isFinite(kW)?kW:0).toFixed(2)+' kW';
  document.getElementById('hp').innerText = (isFinite(hp)?hp:0).toFixed(2)+' hp';

  const duty = Math.min(1, Math.max(0, parseFloat(document.getElementById('duty').value || '1')));
  const batteryWh = Math.max(0, parseFloat(document.getElementById('batteryWh').value || '0'));
  const dailyWh = (P * 24) * duty; const dailyKWh = dailyWh / 1000;
  document.getElementById('dailyKWh').innerText = 'Daily: ' + (isFinite(dailyKWh)?dailyKWh:0).toFixed(2) + ' kWh';
  const hours = P > 0 ? (batteryWh / P) : Infinity;
  document.getElementById('timeToFill').innerText = 'Charge time: ' + (isFinite(hours)?hours.toFixed(1):'–') + ' h';
}

// Wire controls
document.getElementById('recalc').addEventListener('click', () => {
  if(active){ profileForPolyline(active); return; }
  const polys = []; drawn.eachLayer(x => { if(x instanceof L.Polyline && !(x instanceof L.Polygon)) polys.push(x); });
  const last = polys[polys.length-1];
  if(last){ setActive(last); profileForPolyline(last); }
  else alert('Draw a line (intake → powerhouse) with the pencil tool.');
});

document.getElementById('clear').addEventListener('click', () => {
  drawn.clearLayers(); vegGroup.clearLayers(); endpoints.clearLayers(); intakeMarker=null; powerhouseMarker=null;
  chart.data.labels=[]; chart.data.datasets[0].data=[]; chart.update();
  ['len','z0','z1','drop','slope','gain','loss','activeName','powerW','powerkW','hp','dailyKWh','timeToFill'].forEach(id=>document.getElementById(id).innerText='–');
  active = null; lineSeq = 0;
});

document.querySelectorAll('.chip').forEach(chip => chip.addEventListener('click', () => {
  const v = parseFloat(chip.textContent.trim());
  document.getElementById('flowCFS').value = v.toFixed(2);
  const headFt = parseFloat(document.getElementById('drop').innerText) || 0; computePower(headFt);
}));
['flowCFS','eta','batteryWh','duty'].forEach(id => document.getElementById(''+id).addEventListener('input', () => {
  const headFt = parseFloat(document.getElementById('drop').innerText) || 0; computePower(headFt);
}));

// --- Upload GeoJSON layers & roles ---
const uploadedLayers = []; // {layer, name, role, color, gj}
function randomColor() {
  const h = Math.floor(Math.random() * 360);
  return `hsl(${h}deg 70% 45%)`;
}
function addGeoJsonToMap(gj, name, role){
  const color = randomColor();
  const style = { color, weight:2, opacity:0.9, fillOpacity:0.12 };
  const layer = L.geoJSON(gj, {
    style: () => style,
    onEachFeature: (feature, lyr) => {
      const props = Object.entries(feature.properties || {}).map(([k, v]) => `<div><b>${k}</b>: ${String(v)}</div>`).join("");
      lyr.bindPopup(`<div class='small'><b>${name}</b>${props ? `<hr/>${props}` : ""}</div>`);
    },
    pointToLayer: (feature, latlng) => L.circleMarker(latlng, { ...style, radius: 5 }),
  }).addTo(map);
  uploadedLayers.push({ layer, name, role, color, gj });
  refreshUploadedList();
}

function refreshUploadedList(){
  let sep = document.getElementById('uploadedSep');
  if(!sep){
    sep = document.createElement('div'); sep.id='uploadedSep'; sep.className='divider'; layerList.appendChild(sep);
    const h = document.createElement('div'); h.innerHTML = '<b>Uploaded layers</b>'; layerList.appendChild(h);
  }
  const existing = document.getElementById('uploadedList') || (()=>{ const d=document.createElement('div'); d.id='uploadedList'; layerList.appendChild(d); return d; })();
  existing.innerHTML = '';
  uploadedLayers.forEach((entry, idx) => {
    const row = document.createElement('div');
    row.className = 'layer-row';
    row.innerHTML = `<div style="width:10px;height:10px;border-radius:2px;background:${entry.color};"></div>
      <div>${entry.name} <span class="small">(${entry.role})</span></div>
      <button class="btn secondary" data-vis="${idx}">Toggle</button>
      <button class="btn ghost" data-del="${idx}">Remove</button>`;
    existing.appendChild(row);
  });
  existing.querySelectorAll('button[data-vis]').forEach(btn => btn.addEventListener('click', e => {
    const i = +e.target.getAttribute('data-vis');
    const ent = uploadedLayers[i];
    if (!ent) return;
    if (map.hasLayer(ent.layer)) map.removeLayer(ent.layer); else ent.layer.addTo(map);
  }));
  existing.querySelectorAll('button[data-del]').forEach(btn => btn.addEventListener('click', e => {
    const i = +e.target.getAttribute('data-del');
    const ent = uploadedLayers[i];
    if (!ent) return;
    map.removeLayer(ent.layer);
    uploadedLayers.splice(i,1);
    refreshUploadedList();
  }));
}

document.getElementById('geojsonFile').addEventListener('change', async (evt) => {
  const file = evt.target.files[0];
  if (!file) return;
  const name = file.name.replace(/\.(geo)?json$/i, '');
  const text = await file.text();
  try {
    const gj = JSON.parse(text);
    addGeoJsonToMap(gj, name, 'custom');
  } catch (err) {
    console.error(err);
    alert('Invalid GeoJSON.');
  }
});

document.getElementById('assignRole').addEventListener('click', () => {
  const sel = document.getElementById('layerRole').value;
  const nameOverride = document.getElementById('layerName').value.trim();
  const last = uploadedLayers[uploadedLayers.length - 1];
  if (!last) { alert('Upload a layer first.'); return; }
  last.role = sel;
  if (nameOverride) last.name = nameOverride;
  refreshUploadedList();
});

// Export/Import user drawings (notes)
function exportNotes(){
  const feats = [];
  drawn.eachLayer(l => { try { feats.push(l.toGeoJSON()); } catch(e){} });
  vegGroup.eachLayer(l => { try { const f = l.toGeoJSON(); f.properties = Object.assign({}, f.properties||{}, {layer:'vegetation'}); feats.push(f); } catch(e){} });
  const fc = { type:'FeatureCollection', features: feats };
  const blob = new Blob([JSON.stringify(fc, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eh1003006_annotations_v5.2.8.geojson'; a.click(); URL.revokeObjectURL(url);
}
document.getElementById('exportNotes').addEventListener('click', exportNotes);
document.getElementById('importNotes').addEventListener('change', async (evt) => {
  const file = evt.target.files[0];
  if (!file) return;
  try {
    const gj = JSON.parse(await file.text());
    drawn.clearLayers(); vegGroup.clearLayers();
    L.geoJSON(gj).eachLayer((layer) => drawn.addLayer(layer));
  } catch (err) {
    console.error(err);
    alert('Bad GeoJSON.');
  }
});

// --- Drawing logic ---
let lineSeq = 0, active = null;
function nameLine(l){ lineSeq++; l._lineName = 'Line ' + lineSeq; return l._lineName; }
function setActive(l){ active = l; document.getElementById('activeName').innerText = l? (l._lineName || 'Line') : '–'; highlight(l); }
function highlight(line){
  drawn.eachLayer(l => { if(l.setStyle){ l.setStyle({ color: vegGroup.hasLayer(l) ? '#7e22ce' : '#e2e8f0', weight:3, dashArray:null }); } });
  if(line && line.setStyle){ line.setStyle({ color: vegGroup.hasLayer(line) ? '#7e22ce' : '#f59e0b', weight:5, dashArray:'6,4' }); }
}

const intakeIcon = L.divIcon({ className: 'intake-icon', html: '<div style="background:#2563eb;color:#fff;padding:3px 6px;border-radius:6px;border:1px solid #1d4ed8;">Intake</div>' });
const powerhouseIcon = L.divIcon({ className: 'ph-icon', html: '<div style="background:#065f46;color:#fff;padding:3px 6px;border-radius:6px;border:1px solid #064e3b;">Powerhouse</div>' });
let intakeMarker = null, powerhouseMarker = null;
function updateEndpoints(line){
  try{
    const latlngs = line.getLatLngs();
    if(!latlngs || latlngs.length < 2) return;
    const start = latlngs[0], end = latlngs[latlngs.length - 1];
    if(!intakeMarker){ intakeMarker = L.marker(start, { icon: intakeIcon }).addTo(endpoints); } else { intakeMarker.setLatLng(start); }
    if(!powerhouseMarker){ powerhouseMarker = L.marker(end, { icon: powerhouseIcon }).addTo(endpoints); } else { powerhouseMarker.setLatLng(end); }
  }catch(e){}
}

map.on('pm:create', e => {
  const l = e.layer;
  if(l instanceof L.Polyline && !(l instanceof L.Polygon)){
    drawn.addLayer(l);
    nameLine(l); setActive(l);
    try { l.bindTooltip(labelDistance(l), {permanent:true}).openTooltip(); } catch(err){}
    l.on('click', ()=>{ setActive(l); profileForPolyline(l); });
    updateEndpoints(l);
    profileForPolyline(l);
  } else if (l instanceof L.Polygon) {
    const target = vegMode ? vegGroup : drawn;
    target.addLayer(l);
    const style = vegMode ? { color:'#7e22ce', fillColor:'#7e22ce', fillOpacity:0.25 } : { color:'#e2e8f0', fillOpacity:0.15 };
    if(l.setStyle) l.setStyle(style);
    try { l.bindTooltip(labelAreaForPolygon(l), {permanent:true}).openTooltip(); } catch(err){}
  } else if (l instanceof L.Circle) {
    const target = vegMode ? vegGroup : drawn;
    target.addLayer(l);
    try { l.bindTooltip(labelAreaForCircle(l), {permanent:true}).openTooltip(); } catch(err){}
  } else {
    drawn.addLayer(l);
  }
});
map.on('pm:edit', e => {
  const l = e.layer;
  if(l instanceof L.Polyline && !(l instanceof L.Polygon)){
    if(l.getTooltip) l.setTooltipContent(labelDistance(l));
    if(l === active){ updateEndpoints(l); profileForPolyline(l); }
  } else if (l instanceof L.Polygon) {
    if(l.getTooltip) l.setTooltipContent(labelAreaForPolygon(l));
  } else if (l instanceof L.Circle) {
    if(l.getTooltip) l.setTooltipContent(labelAreaForCircle(l));
  }
});

// Labels and measures
function labelDistance(layer){
  try {
    const coords = (layer.getLatLngs().flat ? layer.getLatLngs().flat() : layer.getLatLngs()).map(ll => [ll.lng, ll.lat]);
    const line = turf.lineString(coords);
    const meters = turf.length(line, {units:'kilometers'}) * 1000.0;
    return (meters*3.28084).toFixed(0) + ' ft';
  } catch(e){ return ''; }
}
function labelAreaForPolygon(layer){
  try {
    const rings = layer.getLatLngs()[0] || layer.getLatLngs();
    const coords = rings.map(ll => [ll.lng, ll.lat]);
    const poly = turf.polygon([[...coords, coords[0]]]);
    const sqm = turf.area(poly);
    return (sqm/4046.85642).toFixed(3) + ' acres';
  } catch(e){ return ''; }
}
function labelAreaForCircle(layer){
  try {
    const a = Math.PI * Math.pow(layer.getRadius(), 2);
    return (a/4046.85642).toFixed(3) + ' acres';
  } catch(e){ return ''; }
}

// --- Analyzer (rule checks) ---
function turfFCFromRole(role) {
  const feats = [];
  uploadedLayers.filter(l => l.role === role).forEach(l => feats.push(...l.gj.features));
  return turf.featureCollection(feats);
}

function analyzeSelected(){
  const report = document.getElementById('report');
  report.innerHTML = '';

  const userFeats = [];
  drawn.eachLayer(l => { try { userFeats.push(l.toGeoJSON()); } catch(e){} });
  const userFC = turf.featureCollection(userFeats);

  const streams = turfFCFromRole('streams');
  const flood = turfFCFromRole('floodplain');
  const wetlands = turfFCFromRole('wetlands');
  const slopes = turfFCFromRole('slope');
  const aspects = turfFCFromRole('aspect');
  const blackberries = turfFCFromRole('blackberry');
  const parcel = turfFCFromRole('parcel');

  userFC.features.forEach((f, idx) => {
    const id = f.properties?.id || `feature_${idx+1}`;
    const type = f.geometry?.type || '?';

    const centroid = turf.centroid(f);
    const pt = centroid;

    const notes = [];

    // Streams setback
    if (streams.features.length) {
      const nearest = streams.features.map(g => turf.nearestPointOnLine(g, pt)).sort((a,b) => a.properties.dist - b.properties.dist)[0];
      if (nearest && nearest.properties) {
        const d = nearest.properties.dist; // meters
        if (d < 15.24) notes.push(`⚠️ Within ${d.toFixed(1)} m of a mapped stream (target ≥ 15.2 m / 50 ft).`);
        else notes.push(`✅ ${d.toFixed(1)} m from nearest stream.`);
      }
    }

    // Flood / Wetlands intersects
    function intersectsAny(coll, label) {
      const hit = coll.features.some(g => turf.booleanIntersects(f, g));
      if (hit) notes.push(`⚠️ Intersects ${label}. Consider alternate siting or permits.`);
    }
    if (flood.features.length) intersectsAny(flood, 'floodplain');
    if (wetlands.features.length) intersectsAny(wetlands, 'wetlands');

    // Slope check (expect polygons with slope_pct property)
    if (slopes.features.length) {
      const hits = slopes.features.filter(g => turf.booleanIntersects(f, g));
      if (hits.length) {
        const maxSlope = Math.max(...hits.map(g => Number(g.properties?.slope_pct ?? 0)));
        if (maxSlope >= 30) notes.push(`⚠️ Max slope in footprint ≈ ${maxSlope}% (≥30% is steep).`);
        else notes.push(`✅ Slopes in footprint < 30% (max ≈ ${maxSlope}%).`);
      }
    }

    // Aspect preference
    if (aspects.features.length) {
      const hit = aspects.features.find(g => turf.booleanPointInPolygon(pt, g));
      if (hit) {
        const aspect = String(hit.properties?.aspect ?? '?');
        if (['S','SE','SW'].includes(aspect)) notes.push(`✅ Aspect ${aspect} is favorable for sun.`);
        else notes.push(`ℹ️ Aspect ${aspect}. May reduce winter sun.`);
      }
    }

    // Invasives overlap
    if (blackberries.features.length) {
      const hit = blackberries.features.some(g => turf.booleanIntersects(f, g));
      if (hit) notes.push(`🫐 Intersects mapped blackberry. Budget clearing + tarp/solarization cycles.`);
    }

    // Parcel bounds
    if (parcel.features.length) {
      let merged = parcel.features[0];
      for (let i=1;i<parcel.features.length;i++){ try{ merged = turf.union(merged, parcel.features[i]); }catch{} }
      if (merged && !turf.booleanWithin(f, merged)) notes.push('⚠️ Partially or fully outside parcel boundary.');
    }

    const [lng, lat] = pt.geometry.coordinates;
    const popupHtml = `<div class='small'><b>${id}</b> (${type})<br/>${notes.map(n => `<div>• ${n}</div>`).join('')}</div>`;
    L.popup({ maxWidth: 360 }).setLatLng([lat,lng]).setContent(popupHtml).openOn(map);

    const div = document.createElement('div');
    div.innerHTML = `<div style="margin-bottom:6px;"><b>${id}</b> (${type})</div>${notes.map(n => `<div>• ${n}</div>`).join('')}`;
    report.appendChild(div);
  });

  if (!userFC.features.length) {
    report.innerHTML = '<div class="small">No user features to analyze. Draw polygons/lines/points first.</div>';
  }
}
document.getElementById('analyzeBtn').addEventListener('click', analyzeSelected);
</script>
</body>
</html>
